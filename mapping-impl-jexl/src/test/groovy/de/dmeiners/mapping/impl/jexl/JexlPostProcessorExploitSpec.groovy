package de.dmeiners.mapping.impl.jexl

import de.dmeiners.mapping.api.ExecutionException
import de.dmeiners.mapping.api.ResultTypeException
import org.junit.Rule
import org.junit.contrib.java.lang.system.ExpectedSystemExit
import spock.lang.Specification

class JexlPostProcessorExploitSpec extends Specification {

    @Rule
    ExpectedSystemExit exit = ExpectedSystemExit.none()

    def "a script cannot exit the JVM via System.exit()"() {

        given:
        def scriptText = "i = ${input};" +
                "clazz = i.class;" +
                "system = clazz.forName('java.lang.System');" +
                "methods = system.getMethods();" +
                "for(method : methods) { if (method.getName().equals('exit')) { method.invoke(null, 111); } }"
        def target = "Unchanged"
        def subject = new JexlPostProcessor()

        when:
        def script = subject.compileInline(scriptText)
        script.execute(target, [:])

        then:
        thrown(ExecutionException)

        where:
        input << [
                1 as Byte,
                1 as Short,
                1 as Integer,
                1 as Long,
                1 as Float,
                1 as Double,
                true as Boolean,
                "a" as Character
        ]
    }

    def "a script cannot exit the JVM via Runtime.exit()"() {

        given:
        def scriptText = "i = ${input};" +
                "clazz = i.class;" +
                "runtime = clazz.forName('java.lang.Runtime');" +
                "methods = runtime.getMethods();" +
                "for(method : methods) { if (method.getName().equals('getRuntime')) { method.invoke(null).exit(111); } }"
        def target = "Unchanged"
        def subject = new JexlPostProcessor()

        when:
        def script = subject.compileInline(scriptText)
        script.execute(target, [:])

        then:
        thrown(ExecutionException)

        where:
        input << [
                1 as Byte,
                1 as Short,
                1 as Integer,
                1 as Long,
                1 as Float,
                1 as Double,
                true as Boolean,
                "a" as Character
        ]
    }

    def "a script cannot exit the JVM via System.exit() easily"() {

        given:
        def scriptText = "target.exit(111);"
        def target = System
        def subject = new JexlPostProcessor()

        when:
        def script = subject.compileInline(scriptText)
        script.execute(target, [:])

        then:
        thrown(ExecutionException)
    }

    def "a script cannot exit the JVM via Runtime.exit() easily"() {

        given:
        def scriptText = "target.exit(111);"
        def target = Runtime.getRuntime()
        def subject = new JexlPostProcessor()

        when:
        def script = subject.compileInline(scriptText)
        script.execute(target, [:])

        then:
        thrown(ExecutionException)
    }

    def "a script cannot return a type different from the input type"() {

        given:
        def scriptText = "return target.length()"
        def target = "Hello World!"
        def subject = new JexlPostProcessor()

        when:
        def script = subject.compileInline(scriptText)
        script.execute(target, [:])

        then:
        def e = thrown(ResultTypeException)
        e.message == "Script did not return an object of type 'java.lang.String'."
    }
}
